# 수량자 패턴

* 수량 (quantifier)
  * 매치되는 수와 관련된 패턴 문자
  * 욕심 많은 매치(되도록이면 많이 매치), 숫자로 매치 범위 지정, 욕심없는 매치(되도록이면 적게 매치)로 분류

## 하나 이상 매치

* 패턴 문자 : +
  * 욕심 많은(greedy) 매치로 가능한 최대로 매치

* 기능
  * 하나 이상 매치
  * 'aaac'.match(/a+/);
  * a+와 같이 매치할 문자를 +앞에 작성
  * +앞에 작성한 문자가 반드시 매치되어야 하고 매치된 문자가 연속되어 있으면 모두 매치
  * 매치된 문자를 하나의 배열 엘리먼트로 묶어서 반환
  * {1,} 기능과 같음

## 모든 문자 매치

* 패턴 문자 : .+

* 기능
  * 패턴문자 +는 최대로 매치하려는 특성을 갖고 있으며 dot(.)은 .위치에 아무 문자가 있으면 매치되므로 결국 문자가 있으면 계속 매치하게 되어 모든 문자열을 매치
    * 'aaac'.match(/.+/);

## 정규 표현식 최적화

* 전체 분석
  * 무조건 왼쪽에서 오른쪽으로 매치하지 않고 매치 대상과 패턴 전체를 분석한 후 매치를 행함.
* 'abcAB'.match(/.+AB/);
  * .+ 때문에 검색 대상의 문자열이 문자단위로 각각 다 매치되기 때문에 AB와 매치할 것이 없음.
  * 그러므로 결과는 실패이다.
  * 실패되는 것을 방지하기 위해 AB를 매치하고 나머지에 대해 .+ 패턴을 매치
    * .+로 모두 매치 후 나온 결과 중에 뒤에 AB에 해당하는 것이 없으므로 AB로 한번 더 매치를 수행함.
    * 결과적으로 .+로 수행한 결과와 같은 [abcAB]가 되지만 내부적으로는 .+로 매치된 결과로 [abc]를 얻게 되고, AB로 매치된 결과는 [AB]를 얻게 된다.
  * 이를 정규 표현식의 최적화라고 함.

## 없거나 하나 이상 매치

* 패턴 문자 : *
  * 욕심 많은 매치로 가능한 최대로 매치

* 기능
  * 왼쪽에서 오른쪽으로 아울러 오른쪽에서 왼쪽으로 매치
  * '12A'.match(/12C*/);
  * 왼쪽부터 매치하면 12C가 매치되지 않아 매치 실패
  * *표 앞 문자의 매치 여부에 관계없이 그 앞의 문자를 하나 이상 매치
  * 따라서 *앞의 C가 매치되지 않아도 12가 매치되므로 매치 성공

## 없거나 하나만 매치

* 패턴 문자 : ?
  * 욕심 많은 매치로 가능한 최대로 매치
* 기능
  * ? 앞의 문자가 없어도 매치되고 있어도 매치로 처리


## 욕심 많은 매치 메커니즘

* 뒤에서부터 매치
  * 욕심 많은 패턴 문자에 이어 문자열이 있을 때 뒤에서부터 앞으로 올라가면서 매치
  * 그래야 전체 매치가 성공하기 때문이다.
* '123ABCD'.match(/.?AB/);
  1. 앞에서 부터 매치하면 .?가 모두 매치하므로 AB를 매치할 수 없어 매치가 실패된다.
  2. 패턴 전체가 매치되려면 반드시 AB가 매치되어야 한다.
    * 따라서 우선 AB를 매치하면 123이 남는다.
    * 그리고 .?를 사용하여 3을 매치
    * ?가 하나만 매치하므로 3만 매치하고 매치를 종료

## 수에 매치

* 패턴 문자 : {숫자}
* 기능
  * {} 앞의 문자가 {}안의 수 만큼 매치되면 매치로 처리

## 수 이상에 매치

* 패턴 문자 : {숫자,}

## 매치 구간 지정

* 패턴 문자 : {숫자, 숫자}

* 기능
  * 최소와 최대 구간에 매치되면 매치로 처리
  * {숫자, 숫자}에서 첫번째에 최소를 두 번째에 최대를 작성

## 한 번만 매치

* 패턴 문자 : +?
  * 욕심 없는 매치로 가능한 최대로 적게 매치
  * 이를 위해 왼쪽에서 오른쪽으로 매치

* 기능
  * 연속된 모든 문자를 매치하지 않고 한 번만 매치
  * 'AAAAAC'.match(/AA+?/);
    * AA를 여러번 매치할 수 있지만 한 번만 매치

## 최소 매치

* 패턴 문자 : *?

* 기능
  * 가능한 최소로 매치
  * 왼쪽에서 오른쪽으로 매치하며 직전의 문자를 매치하지 않음
  * *과의 차이는 *의 경우 매치된 경우 * 앞의 문자까지 반환하는 반면 *?는 *? 앞의 문자는 제외하고 반환한다.
    * ex) "ABC"를 /ABK*/ 로 매치하는 경우 AB가 반환 (K와 C가 매치되지 않더라도 뒤의 *에 의해 앞의 것 만이라도 매치 처리함)
    * "ABC"를 /ABC*/ 로 매치하는 경우 ABC가 반환
    * "ABC"를 /ABC*?/ 로 매치하는 경우 AB가 반환
